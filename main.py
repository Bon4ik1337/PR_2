# -*- coding: utf-8 -*-
"""Python_Practice2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Skxte55-y578y8Mdm44ZePZWHPjkDQ3G

# I. Рядки (String).

1. Створити пустий рядок двома різними способами.
"""

# Спосіб 1: Використання порожнього літерального рядка
empty_string_1 = ""

# Спосіб 2: Використання конструктора рядка з порожньою послідовністю
empty_string_2 = str()

# Виведення результатів
print("Пустий рядок 1:", empty_string_1)
print("Пустий рядок 2:", empty_string_2)

"""2. Створити рядок з апострофом."""

# Спосіб 1: Використання подвійних лапок
string_with_apostrophe_1 = "Це рядок з апострофом: '"

# Спосіб 2: Екранування апострофа за допомогою оберненого слешу
string_with_apostrophe_2 = 'Це рядок з апострофом: \'\''

# Виведення результатів
print("Рядок з апострофом 1:", string_with_apostrophe_1)
print("Рядок з апострофом 2:", string_with_apostrophe_2)

"""3. Створити рядок з символом переходу на новий рядок та роздрукувати його в консоль."""

# Створення рядка з символом переходу на новий рядок
string_with_newline = "Це рядок з символом переходу на новий рядок.\nЦе новий рядок."

# Виведення результату
print(string_with_newline)

"""4. Зробити рядок з завдання №3 "сирим"(raw), вивести в консоль та порівняти з результатом в попередному завданні."""

# Створення "сирого" рядка з символом переходу на новий рядок
raw_string_with_newline = r"Це рядок з символом переходу на новий рядок.\nЦе новий рядок."

# Виведення результату
print(raw_string_with_newline)

"""Як ви бачите, в "сирому" рядку \n залишається як літерали і не інтерпретується як символ переходу на новий рядок.*місце для коментарів щодо результатів порівняння

5. Створити змінну, що буде посилатися на Ваше прізвище латинкою. Створити форматований рядок, який буде мати вигляд "My surname is ______", де на місці нижніх підкреслень буде Ваше прізвище зі змінної.
"""

# Змінна, що посилається на прізвище
surname = "Bonislavskyi"

# Форматований рядок
formatted_string = f"My surname is {surname}"

# Виведення результату
print(formatted_string)

"""6. Маючи рядок "My dog is crazy." перетворити його на список ["my", "dog", "is", "crazy"]"""

# Початковий рядок
original_string = "My dog is crazy."

# Перетворення рядка на список слів
word_list = original_string.split()

# Виведення результату
print(word_list)

"""# II. Множини (Set).

7. Створити множину без елементів. Після цого за допомогою методу додайте кілька різних елементів до множини. Чи множини є змінним типом даних?
"""

# Створення порожньої множини
my_set = set()

# Виведення порожньої множини
print("Порожня множина:", my_set)

# Додавання елементів до множини
my_set.add(1)
my_set.add("apple")
my_set.add(3.14)

# Виведення множини після додавання елементів
print("Множина після додавання елементів:", my_set)

"""Щодо змінності типу даних, множини в Python є змінним типом. Це означає, що їх можливо змінювати, додавати та видаляти елементи після їх створення.

8. Створити множину, маючи список my_list = [1, 1, 2, 67, 67, 8, 9]. Пояснити, чому "зникли" деякі елементи.
"""

# Створення множини зі списку
my_list = [1, 1, 2, 67, 67, 8, 9]
my_set = set(my_list)

# Виведення множини
print("Множина зі списку:", my_set)

"""9. Створіть дві множини. Продемонстуйте над ними операції: обʼєднання, різниці, пересічі та симетричної різниці. Використовуйте методи, що не змінюють множини, а створюють нові."""

# Створення двох множин
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# Об'єднання множин
union_set = set1.union(set2)
print("Об'єднання множин:", union_set)

# Різниця множин
difference_set = set1.difference(set2)
print("Різниця множин set1 - set2:", difference_set)

# Пересічення множин
intersection_set = set1.intersection(set2)
print("Пересічення множин:", intersection_set)

# Симетрична різниця множин
symmetric_difference_set = set1.symmetric_difference(set2)
print("Симетрична різниця множин:", symmetric_difference_set)

"""10. Створіть множину з пʼяти елементів. За допомогою спеціального методу, вилучіть три елементи один за одним з множини. Чи може гарантуватися порядок елементів у множинах?"""

# Створення множини з п'яти елементів
my_set = {1, 2, 3, 4, 5}

# Виведення початкової множини
print("Початкова множина:", my_set)

# Вилучення трьох елементів
my_set.discard(2)
my_set.discard(4)
my_set.discard(1)

# Виведення множини після вилучення елементів
print("Множина після вилучення елементів:", my_set)

"""У множинах порядок елементів не гарантується. Множини в Python створюються так, щоб забезпечити ефективне використання пам'яті та операцій над множинами, тому порядок елементів може змінюватися в ході використання методів чи операцій.

# III. Словники (Dictionary).

11. Створіть пустий словник двома способами.
"""

empty_dict1 = {}
print("Пустий словник (спосіб 1):", empty_dict1)
empty_dict2 = dict()
print("Пустий словник (спосіб 2):", empty_dict2)

"""12. До одного зі словників вище додайте чотири пари елементів такі, щоб їхні ключі були різних типів."""

my_dict = {}

# Додавання чотирьох пар елементів
my_dict[1] = "one"  # ключ - ціле число
my_dict["two"] = 2  # ключ - рядок
my_dict[3.0] = "three"  # ключ - число з рухомою комою
my_dict[("four", 4)] = "four"  # ключ - кортеж

# Виведення словника після додавання
print("Словник після додавання:", my_dict)

"""\*чи може список бути ключем? а значенням? чому?

У Python ключі словника повинні бути об'єктами, які мають незмінювані (immutable) типи даних. Список є змінюваним (mutable) типом даних, тому не може бути використаний як ключ для словника.

Однак список може бути значенням у словнику, оскільки значення може бути об'єктом будь-якого типу, в тому числі і змінюваним (mutable) типом, таким як список.

13. Використовуючи той самий словник, отримайте по ключу будь-яке значення з наявних. Тепер видаліть цю пару ключ-значення. Спробуйте знову отримати значення по цьому ж ключу. Використовуючи спеціальний метод, виправте помилку.
"""

my_dict = {"key": "value", "name": "John", 42: "answer"}

# Отримання значення за ключем
value = my_dict["name"]
print("Значення за ключем 'name':", value)

# Видалення пари ключ-значення
del my_dict["name"]

value = my_dict.get("name", "За зазначеним ключем значення не знайдено")
print(value)

"""# IV. Оператори порівняння та логічні оператори. Умови.

14. Створіть цілочисленну змінну зі своїм щасливим або улюбленим числом. Напишіть код, який би автоматизовував наступну задачу.

Якщо число парне, помножте його на 2 та виведіть результат на екран.

Але якщо число непарне, помножте його на 3 та додайте 1 і виведіть на екран.
"""

# Задаємо своє щасливе або улюблене число
my_number = 7  # Замініть на своє число

# Перевірка парності числа та виконання відповідної операції
if my_number % 2 == 0:
    result = my_number * 2
    print(f"Число {my_number} парне, результат множення на 2: {result}")
else:
    result = my_number * 3 + 1
    print(f"Число {my_number} непарне, результат множення на 3 та додавання 1: {result}")

"""15. Створіть рядок зі своїм імʼям латинкою. Напишіть код, який би автоматизовував наступну задачу.

Якщо в імені є літера "а"
 або "i", Виведіть на екран повідомлення "A or I is in the name".



Якщо в імені є літери "o" та "n", Виведіть на екран повідомлення "O and N is in the name".

Також якщо в імені немає літери "о", але є "n", Виведіть на екран повідомлення "Only N is in the name".

В решті випадків виведіть на екран повідомлення "There is no N in the name, but there might be O".

Зверніть увагу, що, наприклад, для імені "Antonina" буде виведено два повідомлення.
"""

# Задаємо своє ім'я латинкою
my_name = "Antonina"  # Замініть на своє ім'я

# Перевірка умов та виведення відповідних повідомлень
if 'a' in my_name or 'i' in my_name:
    print("A or I is in the name")

if 'o' in my_name and 'n' in my_name:
    print("O and N is in the name")
elif 'o' not in my_name and 'n' in my_name:
    print("Only N is in the name")
else:
    print("There is no N in the name, but there might be O")

"""# Вітаю! Ви велика(ий) молодець, що впоралась(вся). Похваліть себе та побалуйте чимось приємним. Я Вами пишаюся."""git status